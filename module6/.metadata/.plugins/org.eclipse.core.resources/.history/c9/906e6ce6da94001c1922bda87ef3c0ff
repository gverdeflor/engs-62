/*
 * main.c -- working with Serial I/O and GPIO
 *
 * Assumes the LED's are connected to AXI_GPIO_0, on channel 1,
 * 			   button are connected to AXI_GPIO_1, on channel 1,
 * 			   switches are connected to AXI_GPIO_2 on channel 1
 *
 * Terminal Settings:
 *  -Baud: 115200
 *  -Data bits: 8
 *  -Parity: no
 *  -Stop bits: 1
 */
#include <stdio.h>
#include <stdlib.h>
#include <strings.h>
#include <xgpio.h>							/* Xilinx GPIO functions */
#include <xuartps.h>						/* Xilinx UART functions */
#include "xil_types.h"						/* u32, u16 etc */
#include "platform.h"						/* ZYBOboard interface */
#include "xparameters.h"					/* constants used by the hardware */
#include "led.h"							/* led module interface */
#include "gic.h"							/* interrupt controller interface */
#include "io.h"								/* button and switch module interface */
#include "servo.h"							/* servo module interface */
#include "adc.h"							/* ADC module interface */
#include "wifi.h"							/* WiFi module interace */

/* Possible States */
#define CONFIGURE 0
#define PING 1
#define UPDATE 2
#define READ 3

/* Current State of Controller */
static int state;

/* State Transition Function */
static void change_state() {
	switch(state) {					// based on current state
	case CONFIGURE:					// look at other inputs
		state = <new_state>;		// change state and generate outputs
	case PING:
		state = <new_state>;
	case UPDATE:
		state = <new_state>;
	break;
	}
}

/* Example Callback Function */
static void btn_callback(int btn) {
	// Change state when an interrupt occurs
	change_state();
}

int main() {

	/* Initialize hardware platform and I/O	 */
	init_platform();
	gic_init();
	led_init();
	adc_init();
	servo_init();
	wifi_init();
	io_btn_init(&mycallback);
	io_sw_init(&mycallback);

	/* Initialize UART1 */
	XUartPs_Config *config1 = XUartPs_LookupConfig(XPAR_PS7_UART_1_DEVICE_ID);
	XUartPs_CfgInitialize(&uart1port, config1, config1->BaseAddress);
	XUartPs_SetFifoThreshold(&uart1port,1);
	XUartPs_SetInterruptMask(&uart1port,XUARTPS_IXR_RXOVR);

	/* Connect UART1 interrupt handler to GIC*/
	XUartPs_SetHandler(&uart1port, (XUartPs_Handler)uart1_handler, &uart1port);
	gic_connect(XPAR_XUARTPS_1_INTR, (Xil_InterruptHandler)XUartPs_InterruptHandler, &uart1port);

	/* Initialize UART0 */
	XUartPs_Config *config0 = XUartPs_LookupConfig(XPAR_PS7_UART_0_DEVICE_ID);
	XUartPs_CfgInitialize(&uart0port, config0, config0->BaseAddress);
	XUartPs_SetBaudRate(&uart0port, 9600); // Wi-Fi module default baud rate
	XUartPs_SetFifoThreshold(&uart0port,1);
	XUartPs_SetInterruptMask(&uart0port,XUARTPS_IXR_RXOVR);

	/* Connect UART0 interrupt handler to GIC*/
	XUartPs_SetHandler(&uart0port, (XUartPs_Handler)uart0_handler, &uart0port);
	gic_connect(XPAR_XUARTPS_0_INTR, (Xil_InterruptHandler)XUartPs_InterruptHandler, &uart0port);

	 /*
		* set stdin unbuffered, forcing getchar to return immediately when
		* a character is typed.
		*/
	setvbuf(stdin,NULL,_IONBF,0);

	printf("\n[Hello]\n");

	// Wait for interrupts from UART handler
	while(!done) {
	 sleep(1);
	}
	printf("[done]\n");
	sleep(1);

	// Turn off all I/O
	led_set(ALL, LED_OFF);
	io_btn_close();
	io_sw_close();
	XUartPs_DisableUart(&uart1port);
	XUartPs_DisableUart(&uart0port);
	gic_disconnect(XPAR_XUARTPS_0_INTR);
	gic_disconnect(XPAR_XUARTPS_1_INTR);
	gic_close();

	cleanup_platform();					/* cleanup the hardware platform */
	return 0;
}
