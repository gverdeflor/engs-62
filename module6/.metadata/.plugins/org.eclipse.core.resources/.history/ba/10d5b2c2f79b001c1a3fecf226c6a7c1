/*
 * main.c -- working with Serial I/O and GPIO
 *
 * Assumes the LED's are connected to AXI_GPIO_0, on channel 1,
 * 			   button are connected to AXI_GPIO_1, on channel 1,
 * 			   switches are connected to AXI_GPIO_2 on channel 1
 *
 * Terminal Settings:
 *  -Baud: 115200
 *  -Data bits: 8
 *  -Parity: no
 *  -Stop bits: 1
 */
#include <stdio.h>
#include <stdlib.h>
#include <strings.h>
#include <xgpio.h>							/* Xilinx GPIO functions */
#include <xuartps.h>						/* Xilinx UART functions */
#include "xil_types.h"						/* u32, u16 etc */
#include "platform.h"						/* ZYBOboard interface */
#include "xparameters.h"					/* constants used by the hardware */
#include "led.h"							/* led module interface */
#include "gic.h"							/* interrupt controller interface */
#include "io.h"								/* button and switch module interface */
#include "ttc.h"							/* TTC module interface */
#include "servo.h"							/* servo module interface */
#include "adc.h"							/* ADC module interface */
//#include "wifi.h"							/* WiFi module interface */

/* Possible States */
#define TRAFFIC 0
#define PEDESTRIAN 1
#define TRAIN 2
#define MAINTENANCE 3
//#define LIGHT 4

#define FREQ 10								/* 10Hz project spec */
#define TRAFFIC_FREQ 0.33					/* 0.33Hz frequency for traffic light */
#define MAINTENANCE_FREQ 0.5				/* 0.5Hz frequency for maintenance light */

/* Status Signals */
static bool red_light = FALSE;
static bool yellow_light = FALSE;
static bool green_light = TRUE;
static bool blue_light = FALSE;
static bool gate_closed = FALSE;

/* Control Signals */
static bool walk_button_1 = FALSE;
static bool walk_button_2 = FALSE;
static bool traffic_delay = FALSE;
static bool pedestrian_delay = FALSE;
static bool train_delay = FALSE;
static bool train_arriving = FALSE;
static bool train_clear = FALSE;
static bool maintenance_key = FALSE;
static bool wheel_close = FALSE;

/* Controller State */
static int state;
static int prev_state;
static bool done;

/* Timer Counter */
static int ttc_count;

/* State Transition Function */
static void change_state() {

	// Default states
	green_light = FALSE;
	yellow_light = FALSE;
	red_light = FALSE;
	blue_light = FALSE;
	gate_closed = FALSE;

	switch(state) {
	// Based on current state
	case TRAFFIC:
		// Generate outputs
		green_light = TRUE;

		// Look at other inputs to set next state
		if ((walk_button_1 || walk_button_2)) {
			state = PEDESTRIAN;
			printf("changed to ped\n");
		} else if (train_arriving) {
			state = TRAIN;
		} else if (maintenance_key && wheel_close) {
			state = MAINTENANCE;
		}
		prev_state = TRAFFIC;

	case PEDESTRIAN:
		// Generate outputs
		red_light = TRUE;

		// Look at other inputs to set next state
		if (pedestrian_delay) {
			state = TRAFFIC;
		} else if (train_arriving) {
			state = TRAIN;
		} else if (maintenance_key && wheel_close) {
			state = MAINTENANCE;
		}
		prev_state = PEDESTRIAN;

	case TRAIN:
		// Generate outputs
		red_light = TRUE;
		gate_closed = TRUE;

		// Look at other inputs to set next state
		if (train_clear && train_delay) {
			printf("should not be called 1\n");
			state = TRAFFIC;
		} else if (maintenance_key){
			state = MAINTENANCE;
		}
		prev_state = TRAIN;

	case MAINTENANCE:
		// Generate outputs
		blue_light = TRUE;
		gate_closed = TRUE;

		// Look at other inputs to set next state
		if (maintenance_key == FALSE && wheel_close == FALSE) {
			state = TRAFFIC;
			printf("should not be called 2\n");
		}
		prev_state = MAINTENANCE;

	break;
	}
}

///* Handles timing when changing from green to red light */
//void traffic_stop_light(void) {
//	yellow_light == TRUE;
//	led_rgb('y');
//	sleep(3);
//
//	yellow_light == FALSE;
//	red_light = TRUE;
//	led_rgb('r');
//}
//
///* Handles timing when changing from green to red light */
//void traffic_start_light(void) {
//	yellow_light == TRUE;
//	led_rgb('y');
//	sleep(3);
//
//	yellow_light == FALSE;
//	red_light = TRUE;
//	led_rgb('g');
//}


/* Button Callback Function */
static void btn_callback(u32 val) {
	printf("entered button callback!\n");
	// Change state when an interrupt occurs
	if (val == 0) {
		// Pedestrian Signal 1
		walk_button_1 = TRUE;
		change_state();
	} else if (val == 1) {
		// Pedestrian Signal 2
		walk_button_2 = TRUE;
		change_state();
	}
}

/* Switch Callback Function */
static void sw_callback(u32 val) {
	// Change state when an interrupt occurs
	if (val == 0) {
		// Maintenance Mode
		maintenance_key = TRUE;
		wheel_close = TRUE;
		change_state();
	} else if (val == 1) {
		// Maintenance Clear
		maintenance_key = FALSE;
		wheel_close = FALSE;
		change_state();
	} else if (val == 2) {
		// Train Arrival
		train_arriving = TRUE;
		change_state();
	} else if (val == 3) {
		// Train Clear
		train_clear = TRUE;
		change_state();
	}
}

void ttc_callback(void) {

	// Reset TTC counter if state changes
	if (prev_state != state) {
		ttc_count = 0;
	} else {
		ttc_count++;
	}

	if (state == TRAFFIC) {
		printf("TRAFFIC\n");
//		if ( (prev_state == PEDESTRIAN) || (prev_state == TRAIN) ) {
//			if ((ttc_count % 60) <= 30) {
//				led_rgb('y');
//			}
//		} else {
//			if ((ttc_count % 60) > 30) {
//				led_rgb('g');
//			}
//		}
		led_rgb('g');

	} else if (state == PEDESTRIAN) {
		led_rgb('r');
		printf("PEDESTRIAN\n");

	} else if (state == TRAIN) {
		led_rgb('r');
		printf("TRAIN\n");

	} else if (state == MAINTENANCE) {
		// Blue maintenance light
		if ((ttc_count % 20) <= 10) {
			led_rgb('b');
		} else {
			led_rgb('o');
		}
	}
}

int main() {

	/* Initialize hardware platform and I/O	 */
	init_platform();
	gic_init();
	led_init();
	io_btn_init(&btn_callback);
	io_sw_init(&sw_callback);
	ttc_init(FREQ, &ttc_callback);
	ttc_start();
	adc_init();
	servo_init();
	//wifi_init();

	/* Set initial state */
	state = TRAFFIC;
	done = false;
	printf("\n[Hello]\n");

	/* Main loop does nothing */
	while(!done) {
		sleep(1);		// Do nothing and wait for interrupts
	}
	printf("[done]\n");
	sleep(1);

	// Turn off all I/O and cleanup hardware
	led_set(ALL, LED_OFF);
	io_btn_close();
	io_sw_close();
	ttc_stop();
	ttc_close();
	//wifi_close();
	gic_close();

	cleanup_platform();
	return 0;
}
